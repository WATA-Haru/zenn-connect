---
title: "T | undefined extends Tの解釈を間違っていた話"
emoji: "🐙"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [typescript]
published: false
---

extends を単語で見てみると、extendsは何かを拡張することだ。
T extends Uがあったら、TはUに拡張できるということで、TはUの下位集合になる。

>TypeScriptではextendsキーワードを用いることでジェネリクスの型Tを特定の型に限定することができます。
今回の例では`<T extends HTMLElement>`とすることで型Tは必ずHTMLElementまたはそのサブタイプのHTMLButtonElementやHTMLDivElementであることが保証されるためstyleプロパティに安全にアクセスできるようになります。
https://typescriptbook.jp/reference/generics/type-parameter-constraint#%E5%9E%8B%E5%BC%95%E6%95%B0%E3%81%AB%E5%88%B6%E7%B4%84%E3%82%92%E3%81%A4%E3%81%91%E3%82%8B

今まで、`T extends string`のように、Tがstringの場合みたいに、ジェネリクスでTをargsのように考えていたのでTにユニオン型を入れた場合に誤った認識をしていた。

## 正しいextendsの認識と実務のコードの解釈
基本に立ち返ると、`T extends T | X`はもちろん成り立つ。
`T | X extends T | X` も成り立つ。
しかし、`T | X extends T`は成り立たない。
冷静に考えれば間違わなそうだが、
実際の例では、Tに`ResponseType | undefined` が入る実装で、
以下のようになっていた。

```ts
type IsNullable<K> = K extends (undefined | null) ? true : false
type GetRequestBody<
  Path extends keyof paths,
  Method extends Lowercase<HttpMethods>,
> =
  IsNullable<paths[Path][Method]> extends true
    ? never
    : NonNullable<paths[Path][Method]>["requestBody"] extends 
        | {
            content: {
              "application/json": infer RequestBody;
            };
          }
        | undefined
      ? RequestBody
      : never;
```

pathとmethodを受け取る。
そして、`NonNullable<paths[Path][Method]>["requestBody"]`は `{ content: { "application/json": infer RequestBody }}` もしくは`undefined`を受け取る。

extendsで、
```ts
{ content: { "application/json": infer RequestBody; }; } | undefined
```
がtrueの場合は`RequestBody`を返す。undefinedが返ってきた場合は`RequestBody`は`unknow`になるので、全体の戻り値は`paths[Path][Method]["requestBody"]` の戻り値 `| unknown`になる。

```ts
: NonNullable<paths[Path][Method]>["requestBody"] extends 
    | {
        content: {
          "application/json": infer RequestBody;
        };
      }
    | undefined
  ? RequestBody
  : never;
```

## 誤った認識
以下のように`undefined`がいらないと思っていた。
実行時に型が決まるという認識で型を書いていたが、型レベルの話では実行時も何もないのでそこが認識違いだった。

**間違った認識**

`NonNullable<paths[Path][Method]>["requestBody"]` が`undefined`の場合はconditional typeが`undefined`でfalsyな値になるので`never`型が返る  
`NonNullable<paths[Path][Method]>["requestBody"]` が`content`の場合は、`RequestBody`が返る。したがって下記の書き方でよいと思っていた。

しかし...下記は必ず`never`型になる。  
なぜなら、型と実装時で考え方が違うからだ。実際には  
`NonNullable<paths[Path][Method]>["requestBody"]` は`content | undefined`である。  
`content`のみでは`content | undefined`の上位集合に慣れないため、  
`content | undefined extends content` は常にfalsyになる。  
したがって、常に返り値が`never`になる。

```ts
: NonNullable<paths[Path][Method]>["requestBody"] extends {
    content: {
      "application/json": infer RequestBody;
    };
  }
  ? RequestBody
  : never;
```

